# 一 HASH TABLE

> 序言

---

**说明**

---

和二叉树，链表这一类一样，他是一种数据结构，设计出来用来存放数据，也叫散列表

**需要的基础知识**

---

* 指针
* 数组
* 链表
* 模运算

> 构建

**哈希函数**

哈希函数是更具关键字设计的，有很多种函数

* 散列函数的定义域必须包含全部需要储存的关键字，而值域的方位则依赖于散列表的大小或地址范围
* 散列函数算出来的地址应该能等概率，均匀的分布在整个地址空间，从而减少冲突
* 散列函数尽量简单，能在比较短的时间内就计算出任意关键字对应的散列地址

**常用的HASH函数的构造方法**

* 
* 

**遇到哈希冲突**

* 链表式解决（Separate Chaining）

  1. 遇到冲突后，就在对应模运算后的索引处的值用链表的结构存起来

* 开放地址（Open Addressing）

  1. 线性探测法

     如果遇到冲突，就往下一个之地寻找空位，新位置=原始位置+ i (i是查找次数)

     **缺点：容易扎堆**

  2. 平方探测法

     吐过遇到冲突，就往（原始位置 + i^2）的位置寻找空位。（i代表查找的次数）

     新位置 = 原始位置 + i^2，解决线性探测法的扎堆

  3. 双哈希

     要设置第二个哈希函数，例如HASH2(key) = R - (key %  R)

     R要取比数组尺寸小的质数

     新位置 = 原始位置 + i * HASH2(key)



> 查找HASH

查找过程类似于构造散列表，就给定一个关键字

先根据散列函数计算出其散列地址，然后检查散列地址位置有没有关键字

1. 如果没有，表明该关键字不存爱，返回查找失败
2. 如果有，则检查值是否等于关键字
   * 如果等于关键字，返回查找成功
   * 如果不等于，则按照给定的冲突处理办法来计算下一个散列地址，再用改地址去执行上述过程

> HASH TABLE 查找性能

和装填因子有关

装填因子：散列表的装填因子一般记为α，定义一个表的装满程度

α = n(表中的记录数) / m(表的长度)

α 越大表示表装的越满，发生冲突的几率高，α越小，发生冲突的几率低



> HASH TABLE 满了怎么办

**再次哈希**

新分配一个较大的哈希表，将原来的哈希表再次哈希存入新表

> HASH TABLE 缺点

* 表越满性能越差
* 容易哈希冲突