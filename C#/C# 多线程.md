# C# 多线程

---



​		多线程，我们工作很多年，可能几乎都没有主动使用过，或者用过，但是说不清楚，而且内心特别没有底

> 1.1 根源 运行模型

* 进程：程序在服务器上运行时，占据的计算机资源合集，称之为进程，进程之间不会相互干扰--进程通信比较困难（分布式）

* 线程：程序执行的最小单位，响应操作的最小执行流，线程也包含计算机单元，线程是属于进程的，一个进程可以有多个线程

* 多线程：一个进程里面有多个线程“并发”执行

  

> 1.2 C#

* Thread类(.NetFramework 1. 0 版本)：是一个封装类，是.Net 对象成对象的抽象封装，通过Thread去完成操作，最终是通过向操作系统请求的到的执行流
  	1. CurrentThread：当前线程--任何操作执行都是线程完成的，运行当前这句话的线程
   	2. ManagedThreadId：是.Net 平台给Thread的线程ID
   	3. API 很丰富，可以玩的很花哨，但一般玩不好--因为是系统管理的，响应并不灵敏
   	4. 启动线程没有控制的，可能会死机
* ThreadPool(.NetFramework 2. 0 版本)：是一个封装类,池化资源管理设计思想，线程是一种资源，池化就是做一个容器，容器提前申请几个线程，程序需要使用线程的话就不需要找操作系统创建，直接在池中拿，用完后再放回去，避免频繁的申请和销毁，容器会根据限制的数量去申请和释放
  1. 线程复用
  2. 限制最大线程数量
  3. API 太少 顺序控制特别弱
* Task类(.NetFramework 3. 0 版本)：Task被称之为多线程的最佳实现
  1. Task线程全部是线程池线程
  2. 提供丰富的API
* Parallel类：可以启动多线程，主线程也参与计算，节约一个线程
  1. ParallelOptions轻松控制最大并发数量
* await async：语法糖
  1. await 

> 1.3 线程

* 同步单线程
  1. 是按顺序执行的，每次调用完之后进入下一步，是同一个线程进行的
  2. WinFrom中 同步单线程当有计算操作时会卡界面，主线程(UI)忙于计算，所以不能响应
  3. 慢--因为只有一个线程进行计算
* 异步线程
  1. 发起调用，不等待结束直接进入下一行，动作会有一个新的线程执行
  2. WinFrom中 异步线程不卡界面，计算任务会交给其他子线程主线程已经闲置，可以响应其他操作
  3. 快--因为多个线程进行计算（用资源换时间，但是在某些情况也不一定最快）
  4. 多线程有额外协调管理成本，并不是越多越好
  5. 资源是有上限的
  6. 无序性，启动无序，执行时间的不确定（CPU切片 线程优先级）

> 1.4 线程控制顺序

* 异步回调
* IsCompleted 等待
* 信号量 (Wait()方法)
* EndInvoke() 方法

> 1.5 多线程安全

​		一段代码单线程执行和多线程执行结果不一致，就表明有线程安全问题，假设同一时刻，去增加同一个数据，都是操作同一个内存位置，多个CPU内核同时发布了命令，内存先执行一个再执行一个，就会先覆盖

* 加锁（lock）：是一个语法糖，实际上是Monitor，实际上是锁定一个内存引用
  1. 单线程化，保证代码块任意时刻只有一个线程能进去，其他的先排队

