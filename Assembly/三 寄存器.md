#  三 汇编

## 引言

我们主要从CPU如何执行指令的角度讲解了8086CPU的逻辑结构，形成物理地址的方法，相关的寄存器以及一些指令



> 3.1 内存中字的存储

* 在0地址处开始存放20000(4E20H)
  1. 0号是低地址单元，1号是高地址单元

![image-20200927215704214](C:\Users\Z-X-L\AppData\Roaming\Typora\typora-user-images\image-20200927215704214.png)

* 任何两个地址连续的内存单元，N号单元和N+1号单元，可以将他们看成两个内存单元，也可以卡成一个地址为N的字单元中的高位字节单元和低位字节单元

> 3.2 DS和[Address]

*说明*

---

* CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址
* 在16位CPU中，内存地址由段地址和偏移地址组成
* DS寄存器，通常用来存放要访问的数据的段地址

*操作*

---

一    读取内存数据到寄存器

​		我们要读取内存的数据时，先要将通过`MOV`指令把内存的地址放入通用寄存器，然后再通过`MOV`指令将通用寄存器的地址放入到数据寄存器DS，因为不能直接把内存地址直接存储到数据寄存器DS，最后通过`MOV [[X]X],[0]` （[...]指的是偏移地址，[0]表示偏移地址为0），将数据寄存器DS存放的内存地址(DS * 16 + [...])中的数据放入通用寄存器[[X]X]中。

![image-20200927223431781](C:\Users\Z-X-L\AppData\Roaming\Typora\typora-user-images\image-20200927223431781.png)

* 执行命令时,8086CPU会自动取DS中的数据为内存单元的段地址

* `MOV`指令中的[]说明操作对象是一个内存单元，[]中的0说明这个内存单元的偏移地址是0，它的段地址默认是放在DS中的

* 数据->通用寄存器->段寄存器

  

二   将数据从寄存器数据送入内存

​		我们要将寄存器的数据传入内存中时，先要将通过

`MOV`指令把需要放入数据的地址放入通用寄存器，然后再通过`MOV`指令将通用寄存器的地址放入到数据寄存器DS，因为不能直接把内存地址直接存储到数据寄存器DS，最后通过`MOV [0],[[X]X]` （[...]指的是偏移地址，[0]表示偏移地址为0），将通用寄存器存放的数据放入内存地址(DS * 16 + [...])中。



![image-20200927224911361](C:\Users\Z-X-L\AppData\Roaming\Typora\typora-user-images\image-20200927224911361.png)



**** 只有走地址总线是才会用到段地址，比如访问内存地址 ****



> 3.3 字(汉字)的传送

**说明**

---

* 因为8086CPU是16位的，有16根数据线，所以可一次性传送16位的数据，也就是一次行可以传送一个字（2Byte）

**示例**

----

![image-20200927225622776](C:\Users\Z-X-L\AppData\Roaming\Typora\typora-user-images\image-20200927225622776.png)

* 使用AX是因为一个字需要16位储存

**问题**

---

一

Q:

![image-20200927225957963](C:\Users\Z-X-L\AppData\Roaming\Typora\typora-user-images\image-20200927225957963.png)

A:

​	1.   AX = 1123H

 	2. BX = 8833H
 	3. CX = 8833H

二

Q:

![image-20200927230313855](C:\Users\Z-X-L\AppData\Roaming\Typora\typora-user-images\image-20200927230313855.png)

A:

1. AX = 2C34H
2. BX = 1B12H
3. CX = 0

> 3.4 MOV，ADD，SUB指令

**MOV 指令**

---

`MOV 寄存器,数据` 

`MOV 寄存器,寄存器` 

`MOV 寄存器,内存单元` 

`MOV 内存单元,寄存器 `

`MOV 段寄存器,寄存器` 

`MOV 寄存器,段寄存器` 

**ADD 指令**

---

`ADD 寄存器,数据`   ADD AX,8

`ADD 寄存器,寄存器`   ADD AX,BX

`ADD 寄存器,内存单元`   ADD AX,[0]

`ADD 内存单元,寄存器`   ADD [0],AX

**SUB指令**

----

`SUB 寄存器,数据`   SUB AX,8

`SUB 寄存器,寄存器`   SUB AX,BX

`SUB 寄存器,内存单元`   SUB AX,[0]

`SUB 内存单元,寄存器 `  SUB [0],AX

> 3.5 数据段

**说明**

---

对于16位PC机，我们可以根据需要将一组单元定义为一个段（可以使代码段，可以使数据段）

我们可以将一组长度为N(N <= 64K)，地址连续，起始地址为16的倍数的内存单元当做专门储存数据的内存空间，从而定义一个数据段。

**问题**

---

Q:

![image-20200929223909295](C:\Users\Z-X-L\AppData\Roaming\Typora\typora-user-images\image-20200929223909295.png)

A:

```Assembly
MOV AX,123B
MOV DS,AX 
MOV AX,[0]
ADD AX,[2]
ADD AX,[4] 
#字的数据是两个单元 所以IP的累加值为2 如果是一个单元 就累加1
```

> 3.6 栈

**说明**

---

栈是一种具有特殊访问方式的储存空间，后进去的数据先可以出来，先进去的数据后出来

**操作**

---

* 入栈：将一个元素放到栈顶
* 出栈：从栈顶去除一个元素、



注意：字型数据用两个单元存放，高地址存放高8位，低地址存放低8位

**疑惑**

---

Q: CPU如何知道一段内存空间被当做栈使用

A: 

Q: 执行PUSH和POP的时候，如何知道那个单元的栈顶的单元

A:在段寄存器 `SS` 存放栈顶的段地址 寄存器 `SP` 存放栈顶的偏移地址 任意时刻，SS:SP 指向栈顶元素

> 3.7 CPU提供的栈的机制

说明

---

* 现如今的CPU中都有栈的设计
* CPU提供相关的指令来以栈的方式访问内存空间
* 这意味着，我们可以将一段内存当做栈来使用

**指令**

---

`PUSH [[X]X]` 将数据推入栈中

![image-20201001104145550](C:\Users\Z-X-L\AppData\Roaming\Typora\typora-user-images\image-20201001104145550.png)

`POP [[X]X]` 从栈顶取出数据

![image-20201001105458755](C:\Users\Z-X-L\AppData\Roaming\Typora\typora-user-images\image-20201001105458755.png)

> 3.8 栈顶越界的问题

**说明**

---

SS 和 SP 只记录了栈顶的地址，依靠SS和SP可以保证在入栈和出栈时找到栈顶，但是如何保证栈不被溢出呢 

**栈顶越界是危险的**

---

因为我们既然讲一段空间安排为战，那么在栈空间支出的空间里很肯能存放了具有其他用途的数据，代码等，这些数据，代码可能是我们自己程序中的，也可能是别的程序中的

**结论**

---

* 我们在编程的时候要注意自己操心栈顶和超界的问题，要根据可能用到的最大栈的空间，来安排栈的打下，防止入栈的数据太多而导致的越界

* 执行入栈和出栈也要注意越界问题

> 3.9 PUSH，POP 指令

`PUSH 寄存器`   PUSH AX

`PUSH 段寄存器`   PUSH DS

`PUSH 内存单元`   PUSH [0]

`POP 寄存器`   POP AX

`POP 段寄存器`   POP DS

`POP 内存单元`   POP [0]

> 3.10 栈段

说明

---

* 我们可以将长度为N的一组连续地址，起始地址为16（16位机器）的倍数的内存单元

，当做栈来使用

* 讲一段内存当做栈段，仅仅是我们在编程的一种
* 安排，CPU并不会由于这种安排，就在执行PUSH,POP等栈操作指令就自动的将我们定义的栈段当做栈空间来访问
* 将SS:SP 指向我们定义的栈段

> 总结

* 我们一定要清楚，什么是我们的安排，以及如何让CPU按我们的安排行事，不管我们怎么安排，CPU将内存中的某段当做代码段，是因为CS:IP指向了那里，CPU将某段内存当做栈，是因为SS:SP指向了那里